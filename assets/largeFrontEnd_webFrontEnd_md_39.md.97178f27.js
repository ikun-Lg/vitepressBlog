import{_ as e,o as a,c as t,S as r}from"./chunks/framework.350e47e2.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"largeFrontEnd/webFrontEnd/md/39.md","filePath":"largeFrontEnd/webFrontEnd/md/39.md","lastUpdated":null}'),p={name:"largeFrontEnd/webFrontEnd/md/39.md"},n=r('<h2 id="七、webpack" tabindex="-1">七、webpack <a class="header-anchor" href="#七、webpack" aria-label="Permalink to &quot;七、webpack&quot;">​</a></h2><h3 id="_1-webpack打包和不打包的区别" tabindex="-1">1.webpack打包和不打包的区别？ <a class="header-anchor" href="#_1-webpack打包和不打包的区别" aria-label="Permalink to &quot;1.webpack打包和不打包的区别？&quot;">​</a></h3><p>​ 1.运行效率</p><p>​ 2.对基础的支持不够</p><h3 id="_2-webpack是怎么打包的-babel是做什么的" tabindex="-1">2.webpack是怎么打包的？babel是做什么的？ <a class="header-anchor" href="#_2-webpack是怎么打包的-babel是做什么的" aria-label="Permalink to &quot;2.webpack是怎么打包的？babel是做什么的？&quot;">​</a></h3><p>​ webpack会把js css image看做是一个模块，用import/require引入</p><p>​ 找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起</p><p>​ 把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件</p><p>​ 如果一个文件被多个文件引用，打包只会生成一个文件</p><p>​ 如果引用的文件没有被调用，不会打包，如果引入的变量和方法没有调用也不会打包</p><p>​ 对于多个入口文件，加入引入了相同的代码，可以用插件把它抽离到公共文件当中</p>',11),o=[n];function c(d,l,_,b,s,i){return a(),t("div",null,o)}const m=e(p,[["render",c]]);export{k as __pageData,m as default};
